# Task T-1.1.2: Configuration System

## Meta
| Field | Value |
|-------|-------|
| Task ID | T-1.1.2 |
| Milestone | M1: Foundation |
| Module | M1-MOD1: Project Initialization |
| Priority | High |
| Effort | 6h |
| Estimated Tokens | 30K |
| Recommended Model | Sonnet |
| Dependencies | T-1.1.1 |
| Parallel Group | — |
| AC Mapping | AC-015, AC-016 |

## Objective
Implement a robust configuration system with 3-tier precedence (environment variables > local config file > defaults), validated by Zod schemas. The configuration system must fail fast on invalid or missing required configuration, preventing the server from starting in an inconsistent state. This component is consumed by every other part of the system.

## Acceptance Criteria
- [ ] Configuration loader implements 3-tier precedence: environment variables override local config file, which overrides defaults
- [ ] Zod validation schema covers all configuration sections: `servicenow`, `auth`, `modules`, `rate_limit`, `circuit_breaker`, `logging`
- [ ] Defaults file provides sensible production defaults for all non-sensitive settings
- [ ] Server fails fast with descriptive error messages when required configuration is missing or invalid (AC-015)
- [ ] Auth configuration is discriminated by `auth.type` — each type requires its own credential fields
- [ ] Module configuration supports per-module `enabled` and `allow_write` flags (AC-016)
- [ ] Sensitive values (passwords, tokens, client secrets) can only be provided via environment variables — never from config files
- [ ] Configuration is exported as a strongly-typed, readonly TypeScript object
- [ ] Unit tests verify: default loading, env var override, validation failure messages, auth type discrimination

## Technical Notes

### File Structure
```
src/config/
  index.ts      # Config loader — loadConfig() function
  schema.ts     # Zod schemas for all config sections
  defaults.ts   # Default values for non-sensitive settings
```

### Configuration Schema (Zod)
```typescript
// Top-level schema structure
const configSchema = z.object({
  servicenow: z.object({
    instance: z.string().min(1),    // e.g., "mycompany" or "mycompany.service-now.com"
    timeout: z.number().default(30000),
    max_retries: z.number().default(3),
  }),
  auth: z.discriminatedUnion("type", [
    z.object({ type: z.literal("basic"), username: z.string(), password: z.string() }),
    z.object({ type: z.literal("oauth"), client_id: z.string(), client_secret: z.string() }),
    z.object({ type: z.literal("token"), token: z.string() }),
  ]),
  modules: z.object({
    generic:   z.object({ enabled: z.boolean(), allow_write: z.boolean() }),
    knowledge: z.object({ enabled: z.boolean(), allow_write: z.boolean() }),
    incident:  z.object({ enabled: z.boolean(), allow_write: z.boolean() }),
    change:    z.object({ enabled: z.boolean(), allow_write: z.boolean() }),
    problem:   z.object({ enabled: z.boolean(), allow_write: z.boolean() }),
    cmdb:      z.object({ enabled: z.boolean(), allow_write: z.boolean() }),
    catalog:   z.object({ enabled: z.boolean(), allow_write: z.boolean() }),
    user:      z.object({ enabled: z.boolean() }),  // No allow_write — user module is read-only
  }),
  rate_limit: z.object({
    max_per_hour: z.number().default(1000),
    burst_size: z.number().default(20),
  }),
  circuit_breaker: z.object({
    enabled: z.boolean().default(false),
    failure_threshold: z.number().default(5),
    reset_timeout_ms: z.number().default(30000),
  }),
  logging: z.object({
    level: z.enum(["trace", "debug", "info", "warn", "error", "fatal"]).default("info"),
  }),
});
```

### Environment Variable Mapping
Use a consistent prefix convention:
- `SERVICENOW_INSTANCE` -> `servicenow.instance`
- `SERVICENOW_AUTH_TYPE` -> `auth.type`
- `SERVICENOW_USERNAME` -> `auth.username` (when type=basic)
- `SERVICENOW_PASSWORD` -> `auth.password` (when type=basic)
- `SERVICENOW_CLIENT_ID` -> `auth.client_id` (when type=oauth)
- `SERVICENOW_CLIENT_SECRET` -> `auth.client_secret` (when type=oauth)
- `SERVICENOW_TOKEN` -> `auth.token` (when type=token)
- `MODULE_GENERIC_ENABLED` -> `modules.generic.enabled`
- `MODULE_GENERIC_ALLOW_WRITE` -> `modules.generic.allow_write`
- `LOG_LEVEL` -> `logging.level`

### 3-Tier Loading Strategy
1. Start with defaults from `defaults.ts`
2. Merge with local config file (if exists) — JSON file at a configurable path
3. Override with environment variables (highest precedence)
4. Validate the merged result with Zod schema
5. If validation fails, throw descriptive error with all Zod issues formatted

### Fail-Fast Pattern
```typescript
export function loadConfig(): AppConfig {
  const raw = mergeConfigSources();
  const result = configSchema.safeParse(raw);
  if (!result.success) {
    const issues = result.error.issues.map(i => `  - ${i.path.join(".")}: ${i.message}`).join("\n");
    throw new Error(`Invalid configuration:\n${issues}`);
  }
  return Object.freeze(result.data);
}
```

### Key Decisions
- No `dotenv` package — use `process.env` directly; `.env` files are loaded by the shell or container runtime
- Config object is frozen (`Object.freeze`) after validation to prevent runtime mutation
- Auth credentials are validated based on discriminated union — e.g., `basic` type requires `username` + `password`
- Module defaults: all modules `enabled: true`, all `allow_write: false` (safe default)

## Token Estimation Rationale
| Component | Tokens |
|-----------|--------|
| Zod schema definition (schema.ts) | 8K |
| Config loader with 3-tier merge (index.ts) | 8K |
| Defaults file (defaults.ts) | 3K |
| Environment variable mapping logic | 4K |
| Unit tests (validation, overrides, fail-fast) | 5K |
| Debugging buffer (10%) | 2K |
| **Total** | **30K** |
