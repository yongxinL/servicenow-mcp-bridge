# Task T-1.5.1: MCP Server + Stdio Transport

## Meta
| Field | Value |
|-------|-------|
| Task ID | T-1.5.1 |
| Milestone | M1: Foundation |
| Module | M1-MOD5: MCP Server Core |
| Priority | High |
| Effort | 3h |
| Estimated Tokens | 18K |
| Recommended Model | Sonnet |
| Dependencies | T-1.1.2, T-1.2.1 |
| Parallel Group | — |
| AC Mapping | AC-001 |

## Objective
Create the MCP server instance using `@modelcontextprotocol/sdk` and wire the stdio transport for communication with MCP clients (Claude Desktop, Cursor, etc.). Implement the main entry point (`src/index.ts`) that orchestrates the startup sequence: load configuration, initialize the logger, create the authentication strategy, instantiate the ServiceNow client, create the MCP server, and start listening on stdio. The server should handle graceful shutdown on SIGINT/SIGTERM.

## Acceptance Criteria
- [ ] MCP server is created using `McpServer` from `@modelcontextprotocol/sdk/server/mcp.js` with server name and version (AC-001)
- [ ] Stdio transport is wired using `StdioServerTransport` from `@modelcontextprotocol/sdk/server/stdio.js`
- [ ] Entry point (`src/index.ts`) executes the full startup sequence in order: config -> logger -> auth -> client -> server -> connect
- [ ] Server metadata includes `name: "servicenow-mcp-bridge"` and `version` from package.json
- [ ] Startup errors (config validation, auth creation) cause the process to exit with a non-zero code and descriptive error message to stderr
- [ ] Graceful shutdown on SIGINT and SIGTERM signals
- [ ] Server logs startup success message with instance URL and enabled module count
- [ ] The server starts and responds to MCP protocol initialization without any tools registered (tools are added by the module registry in T-1.5.2)

## Technical Notes

### File Structure
```
src/
  index.ts    # Entry point — startup orchestration
  server.ts   # MCP server creation + transport wiring
```

### Entry Point (`src/index.ts`)
```typescript
import { loadConfig } from "./config/index.js";
import { initializeLogger, getLogger } from "./logging/index.js";
import { createAuthStrategy } from "./auth/index.js";
import { ServiceNowClient } from "./client/index.js";
import { createMcpServer, connectStdioTransport } from "./server.js";

async function main(): Promise<void> {
  try {
    // 1. Load and validate configuration
    const config = loadConfig();

    // 2. Initialize logger
    const logger = initializeLogger(config.logging.level);
    logger.info("Starting ServiceNow MCP Bridge...");

    // 3. Create auth strategy
    const authStrategy = createAuthStrategy(config.auth, config.servicenow.instance);

    // 4. Create ServiceNow client
    const client = new ServiceNowClient(
      config.servicenow.instance,
      authStrategy,
      { timeout: config.servicenow.timeout },
    );

    // 5. Create MCP server
    const server = createMcpServer();

    // 6. Register modules (T-1.5.2 will add this step)
    // registerModules(server, client, config);

    // 7. Connect stdio transport
    await connectStdioTransport(server);

    logger.info({
      instance: config.servicenow.instance,
      authType: config.auth.type,
    }, "ServiceNow MCP Bridge started successfully");

    // 8. Graceful shutdown
    setupShutdownHandlers(logger);
  } catch (error) {
    // Startup failure — log to stderr and exit
    console.error("Failed to start ServiceNow MCP Bridge:", error);
    process.exit(1);
  }
}

function setupShutdownHandlers(logger: pino.Logger): void {
  const shutdown = () => {
    logger.info("Shutting down ServiceNow MCP Bridge...");
    process.exit(0);
  };
  process.on("SIGINT", shutdown);
  process.on("SIGTERM", shutdown);
}

main();
```

### Server Creation (`src/server.ts`)
```typescript
import { McpServer } from "@modelcontextprotocol/sdk/server/mcp.js";
import { StdioServerTransport } from "@modelcontextprotocol/sdk/server/stdio.js";

export function createMcpServer(): McpServer {
  return new McpServer({
    name: "servicenow-mcp-bridge",
    version: getVersion(),
  });
}

export async function connectStdioTransport(server: McpServer): Promise<void> {
  const transport = new StdioServerTransport();
  await server.connect(transport);
}

function getVersion(): string {
  // Read version from package.json
  // Option 1: Import package.json (with resolveJsonModule)
  // Option 2: Hardcode version string (simpler, updated during release)
  return "0.1.0";
}
```

### MCP SDK API Usage (v1)
Per ADR-006, use the v1 API (`server.tool()`) with Zod v3 schemas:
```typescript
// Tools will be registered by modules via:
server.tool(
  "tool_name",
  "Tool description for AI discoverability",
  { param: z.string().describe("Parameter description") },
  async (params) => {
    // Handler logic
    return { content: [{ type: "text", text: "result" }] };
  }
);
```

This task only creates the server — tool registration is handled by T-1.5.2 (Module Registry).

### Startup Sequence Diagram
```
main()
  ├── loadConfig()          # Fail-fast on invalid config
  ├── initializeLogger()    # Logger to stderr
  ├── createAuthStrategy()  # Based on config.auth.type
  ├── ServiceNowClient()    # HTTP client for ServiceNow
  ├── createMcpServer()     # MCP server instance
  ├── connectStdioTransport() # Wire stdio for MCP protocol
  └── setupShutdownHandlers()  # SIGINT/SIGTERM
```

### Key Decisions
- **Stdio transport only in v0.1.0**: HTTP transport is optional and deferred to T-4.2.1. Most MCP clients (Claude Desktop, Cursor) use stdio.
- **Fail-fast on startup**: Any error during the startup sequence (config, auth, transport) results in an immediate exit with error output to stderr. The server should never start in a degraded state.
- **No hot reload**: Configuration is loaded once at startup. Changing config requires a server restart. This is standard for MCP servers.
- **Version from constant**: Rather than dynamically reading package.json at runtime, the version string is hardcoded and updated during the release process. This avoids path resolution issues in bundled builds.
- **Server exports McpServer instance**: The module registry (T-1.5.2) needs access to the McpServer to register tools. The server instance is passed explicitly rather than using a global.

### Testing Strategy
- **Server creation**: Verify McpServer is instantiated with correct name and version
- **Transport connection**: Mock StdioServerTransport; verify `server.connect()` is called
- **Startup sequence**: Test `main()` with mocked dependencies; verify correct order of initialization
- **Startup failure**: Mock `loadConfig()` to throw; verify `process.exit(1)` is called
- **Shutdown handlers**: Verify SIGINT/SIGTERM listeners are registered

**Note**: Full integration testing of MCP protocol communication (initialize, tool listing, tool calling) is deferred to T-4.1.3.

## Token Estimation Rationale
| Component | Tokens |
|-----------|--------|
| Entry point orchestration (index.ts) | 5K |
| MCP server creation + transport (server.ts) | 4K |
| Shutdown handler setup | 1K |
| Unit tests (startup, failure, shutdown) | 5K |
| Debugging buffer (15%) | 3K |
| **Total** | **18K** |
