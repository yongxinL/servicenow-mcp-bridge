# Task T-1.3.3: Circuit Breaker

## Meta
| Field | Value |
|-------|-------|
| Task ID | T-1.3.3 |
| Milestone | M1: Foundation |
| Module | M1-MOD3: Resilience Layer |
| Priority | Medium |
| Effort | 3h |
| Estimated Tokens | 18K |
| Recommended Model | Sonnet |
| Dependencies | T-1.2.2 |
| Parallel Group | PG-3 |
| AC Mapping | AC-017 |

## Objective
Implement a circuit breaker with three states (CLOSED, OPEN, HALF_OPEN) that prevents repeated calls to a failing ServiceNow instance. The circuit breaker is config-gated (disabled by default) and optional. When enabled, it tracks consecutive failures and trips open after reaching a configurable threshold, failing fast for subsequent requests until a reset timeout expires and allows a probe request.

## Acceptance Criteria
- [ ] Circuit breaker implements three states: CLOSED, OPEN, HALF_OPEN (AC-017)
- [ ] **CLOSED** state: All requests pass through; failures are counted
- [ ] **OPEN** state: All requests fail immediately with a `CIRCUIT_OPEN` error (fast fail)
- [ ] **HALF_OPEN** state: One probe request is allowed; success closes the circuit, failure re-opens it
- [ ] Configurable `failure_threshold` (default: 5) — number of consecutive failures to trip the circuit
- [ ] Configurable `reset_timeout_ms` (default: 30000) — time to wait before transitioning from OPEN to HALF_OPEN
- [ ] Circuit breaker is config-gated: when `circuit_breaker.enabled = false`, all requests pass through without any circuit breaker logic (AC-017)
- [ ] Only errors deemed "circuit-breaking" (server errors, network errors) increment the failure counter — client errors (4xx) do not
- [ ] Successful requests in CLOSED state reset the failure counter to zero
- [ ] Unit tests verify: state transitions (CLOSED->OPEN->HALF_OPEN->CLOSED), failure counting, reset on success, config-gated bypass, fast fail when open

## Technical Notes

### File Location
```
src/resilience/circuit-breaker.ts
```

### State Machine Design
```
CLOSED ──(failure_threshold reached)──> OPEN
OPEN ──(reset_timeout expires)──> HALF_OPEN
HALF_OPEN ──(probe succeeds)──> CLOSED
HALF_OPEN ──(probe fails)──> OPEN
```

### Implementation
```typescript
export enum CircuitState {
  CLOSED = "CLOSED",
  OPEN = "OPEN",
  HALF_OPEN = "HALF_OPEN",
}

export interface CircuitBreakerConfig {
  enabled: boolean;
  failureThreshold: number;   // Default: 5
  resetTimeoutMs: number;     // Default: 30000
}

export class CircuitBreaker {
  private state: CircuitState = CircuitState.CLOSED;
  private failureCount: number = 0;
  private lastFailureTime: number = 0;

  constructor(private readonly config: CircuitBreakerConfig) {}

  async execute<T>(operation: () => Promise<T>): Promise<T> {
    // Bypass when disabled
    if (!this.config.enabled) {
      return operation();
    }

    if (this.state === CircuitState.OPEN) {
      if (this.shouldAttemptReset()) {
        this.state = CircuitState.HALF_OPEN;
      } else {
        throw new CircuitOpenError(this.remainingResetTime());
      }
    }

    try {
      const result = await operation();
      this.onSuccess();
      return result;
    } catch (error) {
      this.onFailure(error);
      throw error;
    }
  }

  private onSuccess(): void {
    this.failureCount = 0;
    this.state = CircuitState.CLOSED;
  }

  private onFailure(error: unknown): void {
    if (!this.isCircuitBreakingError(error)) return;

    this.failureCount++;
    this.lastFailureTime = Date.now();

    if (this.state === CircuitState.HALF_OPEN || this.failureCount >= this.config.failureThreshold) {
      this.state = CircuitState.OPEN;
    }
  }

  private shouldAttemptReset(): boolean {
    return Date.now() - this.lastFailureTime >= this.config.resetTimeoutMs;
  }

  get currentState(): CircuitState { return this.state; }
}
```

### Circuit-Breaking Error Detection
Only server-side and network errors should trip the circuit. Client errors (4xx) indicate bad requests, not a failing service:

```typescript
private isCircuitBreakingError(error: unknown): boolean {
  if (error instanceof ServiceNowHttpError) {
    return error.statusCode >= 500; // 500, 502, 503, etc.
  }
  // Network errors (TypeError from fetch, AbortError from timeout)
  if (error instanceof TypeError) return true;
  if (error instanceof DOMException && error.name === "AbortError") return true;
  return false;
}
```

**Note**: HTTP 429 is intentionally NOT circuit-breaking — it's handled by the rate limiter and retry handler. Tripping the circuit on 429 would be counterproductive.

### CircuitOpenError
```typescript
export class CircuitOpenError extends Error {
  constructor(public readonly remainingMs: number) {
    super(`Circuit breaker is open. Reset in ${Math.ceil(remainingMs / 1000)}s`);
    this.name = "CircuitOpenError";
  }
}
```

This error is mapped to `CIRCUIT_OPEN` error code by the error normalizer (T-1.4.1).

### Integration Point
The circuit breaker wraps the HTTP operation after retry:
```
Rate Limiter -> Retry Handler -> Circuit Breaker.execute(() => fetch(...))
```

Or alternatively, the circuit breaker can wrap the entire retry sequence:
```
Rate Limiter -> Circuit Breaker.execute(() => withRetry(() => fetch(...)))
```

The second approach is preferred — if the circuit is open, we skip retry attempts entirely.

### Key Decisions
- **Config-gated (disabled by default)**: Circuit breakers add complexity and can cause surprising behavior. Users must opt in via `circuit_breaker.enabled: true`.
- **Consecutive failure counting**: Simpler than sliding window or percentage-based approaches. Appropriate for v0.1.0.
- **Single circuit for all requests**: No per-table or per-module circuits in v0.1.0.
- **No half-open concurrency limit**: In HALF_OPEN state, only one request acts as the probe. Since MCP processes requests sequentially, this is naturally serialized.
- **4xx errors do NOT trip the circuit**: A 404 or 400 is a client mistake, not a service failure.

### Testing Strategy
- **CLOSED -> OPEN**: Send `failureThreshold` failures; verify state transitions to OPEN
- **OPEN fast fail**: After tripping, verify immediate CircuitOpenError without calling operation
- **OPEN -> HALF_OPEN**: Advance time past `resetTimeoutMs`; verify state transitions to HALF_OPEN
- **HALF_OPEN -> CLOSED**: In HALF_OPEN, send successful request; verify state returns to CLOSED
- **HALF_OPEN -> OPEN**: In HALF_OPEN, send failed request; verify state returns to OPEN
- **Success resets counter**: In CLOSED, send failures then a success; verify counter resets
- **Config bypass**: When `enabled: false`, verify all operations pass through regardless of failures
- **Non-circuit-breaking errors**: Verify 4xx errors don't increment failure count

## Token Estimation Rationale
| Component | Tokens |
|-----------|--------|
| CircuitBreaker class with state machine | 6K |
| CircuitOpenError class | 1K |
| Error detection logic | 1K |
| Unit tests (state transitions, config bypass) | 7K |
| Debugging buffer (15%) | 3K |
| **Total** | **18K** |
