# Task T-1.5.2: Module Registry + Feature Flag Gating

## Meta
| Field | Value |
|-------|-------|
| Task ID | T-1.5.2 |
| Milestone | M1: Foundation |
| Module | M1-MOD5: MCP Server Core |
| Priority | High |
| Effort | 4h |
| Estimated Tokens | 25K |
| Recommended Model | Sonnet |
| Dependencies | T-1.5.1 |
| Parallel Group | — |
| AC Mapping | AC-002, AC-003, AC-008, AC-021 |

## Objective
Implement the module registry system that manages ServiceNow domain modules (Incident, Knowledge, CMDB, etc.). The registry reads feature flags from configuration, instantiates only enabled modules, and calls each module's `register()` method to add MCP tools to the server. Write tools are conditionally registered based on per-module `allow_write` flags. The registry defines the `ServiceNowModule` interface and provides the `ALL_MODULES` array for easy extensibility.

## Acceptance Criteria
- [ ] `ServiceNowModule` interface defines: `name`, `description`, and `register(server, client, config)` method (AC-008)
- [ ] `ModuleConfig` type includes `enabled: boolean` and `allow_write: boolean` fields
- [ ] Module registry reads module feature flags from the application configuration (AC-002)
- [ ] Only modules with `enabled: true` are instantiated and registered (AC-002)
- [ ] `register()` is called with the `McpServer`, `ServiceNowClient`, and module-specific config
- [ ] Write tools (create, update, delete) are only registered when `allow_write: true` for that module (AC-003, AC-021)
- [ ] `ALL_MODULES` array serves as the single source of truth for available modules — adding a new module requires only adding an entry to this array
- [ ] Registry logs which modules were enabled/disabled and whether writes are allowed for each
- [ ] Registry handles gracefully when a module fails to register (logs error, continues with other modules)
- [ ] Unit tests verify: enabled module registration, disabled module skipping, write flag gating, ALL_MODULES extensibility, registration error resilience

## Technical Notes

### File Structure
```
src/modules/
  registry.ts   # Module registry — registerModules() function
  types.ts      # ServiceNowModule interface + ModuleConfig type
```

### ServiceNowModule Interface
```typescript
import type { McpServer } from "@modelcontextprotocol/sdk/server/mcp.js";
import type { ServiceNowClient } from "../client/index.js";

export interface ModuleConfig {
  enabled: boolean;
  allow_write: boolean;
}

export interface ServiceNowModule {
  /** Unique module identifier — must match the key in config.modules */
  name: string;

  /** Human-readable description for logging */
  description: string;

  /**
   * Register MCP tools with the server.
   * Read-only tools should always be registered.
   * Write tools should only be registered when config.allow_write is true.
   */
  register(server: McpServer, client: ServiceNowClient, config: ModuleConfig): void;
}
```

### ALL_MODULES Array
```typescript
// All available modules — add new modules here
// Module implementations are imported from their respective directories
// Initially empty — modules are added as they are implemented in M2/M3

export const ALL_MODULES: ServiceNowModule[] = [
  // T-2.1.1: genericModule,
  // T-2.2.1: knowledgeModule,
  // T-2.3.1: incidentModule,
  // T-3.1.1: changeModule,
  // T-3.2.1: problemModule,
  // T-3.3.1: cmdbModule,
  // T-3.4.1: catalogModule,
  // T-3.5.1: userModule,
];
```

Each module task (T-2.x.x, T-3.x.x) is responsible for uncommenting and importing its entry in `ALL_MODULES`.

### Registry Function
```typescript
import type { Logger } from "pino";
import type { McpServer } from "@modelcontextprotocol/sdk/server/mcp.js";
import type { ServiceNowClient } from "../client/index.js";
import type { AppConfig } from "../config/schema.js";

export function registerModules(
  server: McpServer,
  client: ServiceNowClient,
  config: AppConfig,
  logger: Logger,
): void {
  let enabledCount = 0;

  for (const module of ALL_MODULES) {
    const moduleConfig = config.modules[module.name as keyof typeof config.modules];

    if (!moduleConfig) {
      logger.warn({ module: module.name }, "Module has no configuration entry — skipping");
      continue;
    }

    if (!moduleConfig.enabled) {
      logger.debug({ module: module.name }, "Module disabled — skipping");
      continue;
    }

    try {
      const modConfig: ModuleConfig = {
        enabled: moduleConfig.enabled,
        allow_write: "allow_write" in moduleConfig ? moduleConfig.allow_write : false,
      };

      module.register(server, client, modConfig);
      enabledCount++;

      logger.info({
        module: module.name,
        allow_write: modConfig.allow_write,
      }, `Module registered: ${module.description}`);
    } catch (error) {
      logger.error({
        module: module.name,
        error: error instanceof Error ? error.message : String(error),
      }, `Failed to register module: ${module.name} — continuing with other modules`);
    }
  }

  logger.info({ enabledCount, totalAvailable: ALL_MODULES.length }, "Module registration complete");
}
```

### Write Tool Gating Pattern
Each module's `register()` function follows this pattern:

```typescript
// Example: How a module registers tools (implemented in M2/M3 tasks)
function register(server: McpServer, client: ServiceNowClient, config: ModuleConfig): void {
  // Read-only tools — always registered
  server.tool("list_incidents", "List incidents", { ... }, async (params) => { ... });
  server.tool("get_incident", "Get incident by sys_id", { ... }, async (params) => { ... });

  // Write tools — only registered when allow_write is true
  if (config.allow_write) {
    server.tool("create_incident", "Create an incident", { ... }, async (params) => { ... });
    server.tool("update_incident", "Update an incident", { ... }, async (params) => { ... });
  }
}
```

This means write tools simply don't exist in the MCP tool list when `allow_write` is false. AI clients cannot invoke tools that are not registered. This is more secure than runtime authorization checks (ADR-004).

### Integration with Entry Point
After T-1.5.2 is implemented, update `src/index.ts` (from T-1.5.1) to call `registerModules()`:

```typescript
// In main() — after creating server, before connecting transport
const server = createMcpServer();
registerModules(server, client, config, logger);
await connectStdioTransport(server);
```

### Key Decisions
- **Static ALL_MODULES array**: Simple, explicit, no dynamic module discovery. Adding a module is a one-line code change. This avoids file system scanning, dynamic imports, or decorator-based registration.
- **Resilient registration**: A single module failing to register does not prevent other modules from loading. The error is logged and the server continues. This is critical for production stability.
- **Write control at registration time (ADR-004)**: Tools that don't exist can't be called. More secure and simpler than runtime ACL checks.
- **Module config lookup by name**: The module's `name` property must match the key in `config.modules`. This coupling is intentional and enforced by TypeScript types.
- **No dynamic enable/disable**: Modules are registered at startup only. Changing feature flags requires a server restart.

### Testing Strategy
- **Enabled module registration**: Create mock modules; set `enabled: true`; verify `register()` is called
- **Disabled module skipping**: Set `enabled: false`; verify `register()` is NOT called
- **Write flag propagation**: Verify `ModuleConfig.allow_write` value is correctly passed to the module's `register()` method
- **Registration error resilience**: Create a mock module that throws in `register()`; verify other modules still register successfully
- **ALL_MODULES extensibility**: Add a test module to ALL_MODULES; verify it participates in registration
- **Logging**: Verify enabled/disabled/error messages are logged with correct module names
- **Missing config**: Add a module to ALL_MODULES with no matching config entry; verify it's skipped with a warning

## Token Estimation Rationale
| Component | Tokens |
|-----------|--------|
| ServiceNowModule interface + types (types.ts) | 3K |
| Registry function with feature flag logic (registry.ts) | 7K |
| ALL_MODULES array setup | 2K |
| Entry point integration update | 1K |
| Unit tests (enable/disable, write flags, errors) | 9K |
| Debugging buffer (12%) | 3K |
| **Total** | **25K** |
