# Task T-1.2.1: Auth Strategies

## Meta
| Field | Value |
|-------|-------|
| Task ID | T-1.2.1 |
| Milestone | M1: Foundation |
| Module | M1-MOD2: ServiceNow Client |
| Priority | High |
| Effort | 6h |
| Estimated Tokens | 35K |
| Recommended Model | Sonnet |
| Dependencies | T-1.1.1 |
| Parallel Group | PG-2 |
| AC Mapping | AC-001, AC-009, AC-014 |

## Objective
Implement the authentication layer using the Strategy pattern. Define an `AuthStrategy` interface and three concrete implementations: `BasicAuthStrategy` (Base64 username:password), `OAuthStrategy` (Client Credentials grant with token caching and automatic refresh), and `TokenAuthStrategy` (static bearer token). Provide an auth factory function that selects the correct strategy based on configuration.

## Acceptance Criteria
- [ ] `AuthStrategy` interface defines `getAuthHeaders(): Promise<Record<string, string>>` method (AC-001)
- [ ] `BasicAuthStrategy` returns `Authorization: Basic base64(user:pass)` header
- [ ] `OAuthStrategy` implements Client Credentials grant flow against ServiceNow's `/oauth_token.do` endpoint
- [ ] `OAuthStrategy` caches access tokens and auto-refreshes before expiry (with buffer, e.g., 60 seconds before expiry) (AC-014)
- [ ] `OAuthStrategy` handles token refresh failures gracefully with descriptive error
- [ ] `TokenAuthStrategy` returns `Authorization: Bearer {static_token}` header
- [ ] Auth factory function (`createAuthStrategy`) selects strategy based on `config.auth.type`
- [ ] Invalid auth type in config results in clear error at construction time (AC-009)
- [ ] Unit tests cover: each strategy header format, OAuth token caching, OAuth token refresh, factory selection

## Technical Notes

### File Structure
```
src/auth/
  index.ts    # Auth factory — createAuthStrategy(config)
  types.ts    # AuthStrategy interface
  basic.ts    # BasicAuthStrategy
  oauth.ts    # OAuthStrategy
  token.ts    # TokenAuthStrategy
```

### AuthStrategy Interface
```typescript
export interface AuthStrategy {
  /** Returns headers to attach to ServiceNow API requests */
  getAuthHeaders(): Promise<Record<string, string>>;
}
```

Use `Promise` return type even for synchronous strategies (Basic, Token) to maintain a uniform async interface. This allows OAuth to perform token refresh transparently.

### BasicAuthStrategy
```typescript
export class BasicAuthStrategy implements AuthStrategy {
  constructor(private username: string, private password: string) {}

  async getAuthHeaders(): Promise<Record<string, string>> {
    const encoded = Buffer.from(`${this.username}:${this.password}`).toString("base64");
    return { Authorization: `Basic ${encoded}` };
  }
}
```

### OAuthStrategy
- **Token endpoint**: `https://{instance}.service-now.com/oauth_token.do`
- **Grant type**: `client_credentials`
- **Request**: `POST` with `Content-Type: application/x-www-form-urlencoded`
- **Body**: `grant_type=client_credentials&client_id={id}&client_secret={secret}`
- **Response**: `{ access_token, token_type, expires_in }`
- **Caching**: Store token + expiry timestamp in memory
- **Refresh logic**: If current time + buffer (60s) >= expiry, fetch new token before returning headers
- **Thread safety**: Not needed (single-process, single-threaded Node.js), but prevent concurrent refresh requests with a promise lock

```typescript
export class OAuthStrategy implements AuthStrategy {
  private token: string | null = null;
  private expiresAt: number = 0;
  private refreshPromise: Promise<void> | null = null;

  constructor(
    private instanceUrl: string,
    private clientId: string,
    private clientSecret: string,
    private refreshBufferMs: number = 60_000,
  ) {}

  async getAuthHeaders(): Promise<Record<string, string>> {
    if (this.needsRefresh()) {
      await this.refresh();
    }
    return { Authorization: `Bearer ${this.token}` };
  }
}
```

### TokenAuthStrategy
```typescript
export class TokenAuthStrategy implements AuthStrategy {
  constructor(private token: string) {}

  async getAuthHeaders(): Promise<Record<string, string>> {
    return { Authorization: `Bearer ${this.token}` };
  }
}
```

### Auth Factory
```typescript
export function createAuthStrategy(config: AuthConfig, instanceUrl: string): AuthStrategy {
  switch (config.type) {
    case "basic":
      return new BasicAuthStrategy(config.username, config.password);
    case "oauth":
      return new OAuthStrategy(instanceUrl, config.client_id, config.client_secret);
    case "token":
      return new TokenAuthStrategy(config.token);
    default:
      throw new Error(`Unsupported auth type: ${(config as any).type}`);
  }
}
```

### Key Decisions
- OAuth uses native `fetch` (no additional HTTP library) for the token endpoint call
- OAuth token is cached in-memory only (no persistent storage) — lost on server restart is acceptable
- Refresh buffer (60 seconds) prevents edge-case failures when a token expires between header generation and request send
- The auth factory is a plain function, not a class — keeps it simple and testable

### Testing Strategy
- **BasicAuthStrategy**: Verify Base64 encoding of known credentials
- **OAuthStrategy**: Mock `fetch` to simulate token endpoint responses; test caching (second call returns cached token), test refresh (advance time past expiry), test failure handling
- **TokenAuthStrategy**: Verify bearer header with known token
- **Factory**: Test each auth type selection, test invalid type error

## Token Estimation Rationale
| Component | Tokens |
|-----------|--------|
| AuthStrategy interface (types.ts) | 1K |
| BasicAuthStrategy (basic.ts) | 2K |
| OAuthStrategy with caching + refresh (oauth.ts) | 10K |
| TokenAuthStrategy (token.ts) | 2K |
| Auth factory (index.ts) | 2K |
| Unit tests (all strategies + factory) | 12K |
| Debugging buffer (OAuth complexity, 15%) | 6K |
| **Total** | **35K** |
